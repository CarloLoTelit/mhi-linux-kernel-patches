From 28dc0a8fc8e91cd62b990e365fad07cb2484b393 Mon Sep 17 00:00:00 2001
From: Bhaumik Bhatt <bbhatt@codeaurora.org>
Date: Thu, 1 Apr 2021 14:16:14 -0700
Subject: [PATCH 38/58] bus: mhi: core: Hold device wake for channel update
 commands

MHI host can fail early if device is in a bad state by attempting
to assert device wake and holding the runtime PM vote before
sending a channel update command instead of performing a wake
toggle and waiting for a timeout if the send were to fail. This
can help improve the design and enable shorter wait periods for
device to respond as votes are already held.

Signed-off-by: Bhaumik Bhatt <bbhatt@codeaurora.org>
Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
Link: https://lore.kernel.org/r/1617311778-1254-6-git-send-email-bbhatt@codeaurora.org
Signed-off-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
Signed-off-by: Daniele Palmas <dnlplm@gmail.com>
---
 drivers/bus/mhi/core/main.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/drivers/bus/mhi/core/main.c b/drivers/bus/mhi/core/main.c
index ef778389476f..b4b87a9e17a4 100644
--- a/drivers/bus/mhi/core/main.c
+++ b/drivers/bus/mhi/core/main.c
@@ -1286,16 +1286,18 @@ static int mhi_update_channel_state(struct mhi_controller *mhi_cntrl,
 		return -EINVAL;
 	}
 
-	mhi_cntrl->wake_toggle(mhi_cntrl);
+	/* bring host and device out of suspended states */
+	ret = mhi_device_get_sync(mhi_cntrl->mhi_dev);
+	if (ret)
+		return ret;
 	mhi_cntrl->runtime_get(mhi_cntrl);
-	mhi_cntrl->runtime_put(mhi_cntrl);
 
 	reinit_completion(&mhi_chan->completion);
 	ret = mhi_send_cmd(mhi_cntrl, mhi_chan, cmd);
 	if (ret) {
 		dev_err(dev, "%d: Failed to send %s channel command\n",
 			mhi_chan->chan, TO_CH_STATE_TYPE_STR(to_state));
-		return ret;
+		goto exit_channel_update;
 	}
 
 	ret = wait_for_completion_timeout(&mhi_chan->completion,
@@ -1304,9 +1306,12 @@ static int mhi_update_channel_state(struct mhi_controller *mhi_cntrl,
 		dev_err(dev,
 			"%d: Failed to receive %s channel command completion\n",
 			mhi_chan->chan, TO_CH_STATE_TYPE_STR(to_state));
-		return -EIO;
+		ret = -EIO;
+		goto exit_channel_update;
 	}
 
+	ret = 0;
+
 	if (to_state != MHI_CH_STATE_TYPE_RESET) {
 		write_lock_irq(&mhi_chan->lock);
 		mhi_chan->ch_state = (to_state == MHI_CH_STATE_TYPE_START) ?
@@ -1317,7 +1322,11 @@ static int mhi_update_channel_state(struct mhi_controller *mhi_cntrl,
 	dev_dbg(dev, "%d: Channel state change to %s successful\n",
 		mhi_chan->chan, TO_CH_STATE_TYPE_STR(to_state));
 
-	return 0;
+exit_channel_update:
+	mhi_cntrl->runtime_put(mhi_cntrl);
+	mhi_device_put(mhi_cntrl->mhi_dev);
+
+	return ret;
 }
 
 static void __mhi_unprepare_channel(struct mhi_controller *mhi_cntrl,
-- 
2.25.1

